name: Auto Merge and Change Visibility

on:
  pull_request:
    types: [opened, synchronize, reopened]
  schedule:
    # Runs daily at midnight UTC to check for visibility change
    - cron: '0 0 * * *'
  workflow_dispatch: # Allows manual triggering

jobs:
  auto_merge:
    runs-on: ubuntu-latest
    if: github.event_name == 'pull_request' # Only run this job for pull_request events
    permissions:
      contents: write      # Needed to push the timestamp file
      pull-requests: write # Needed to merge PRs
      issues: write        # Needed to create issues on failure
    steps:
      - name: Checkout code
        uses: actions/checkout@v3
        with:
          # Fetch full history to be able to push back to the branch
          fetch-depth: 0 
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Get PR data
        id: pr_data
        run: |
          echo "PR_NUMBER=$(jq --raw-output .pull_request.number "$GITHUB_EVENT_PATH")" >> $GITHUB_OUTPUT
          echo "IS_MERGEABLE=$(jq --raw-output .pull_request.mergeable "$GITHUB_EVENT_PATH")" >> $GITHUB_OUTPUT
          echo "MERGE_STATE=$(jq --raw-output .pull_request.mergeable_state "$GITHUB_EVENT_PATH")" >> $GITHUB_OUTPUT
          # Get head SHA and base ref for commit/push operations
          echo "PR_HEAD_SHA=$(jq --raw-output .pull_request.head.sha "$GITHUB_EVENT_PATH")" >> $GITHUB_OUTPUT
          echo "PR_BASE_REF=$(jq --raw-output .pull_request.base.ref "$GITHUB_EVENT_PATH")" >> $GITHUB_OUTPUT

      - name: Auto-merge PR
        # This step enables GitHub's auto-merge feature.
        # It will merge only if there are no merge conflicts AND all branch protection rules are met (e.g., passing checks, required reviews if any).
        if: steps.pr_data.outputs.IS_MERGEABLE == 'true' && (steps.pr_data.outputs.MERGE_STATE == 'clean' || steps.pr_data.outputs.MERGE_STATE == 'behind' || steps.pr_data.outputs.MERGE_STATE == 'unstable')
        # MERGE_STATE 'clean' means all checks passed and ready.
        # 'behind' means it's not up to date with base, but still potentially mergeable if checks pass after update.
        # 'unstable' means checks are running or some non-required checks failed.
        # GitHub's auto-merge will handle these states and merge when ready (e.g. after auto-update if enabled for 'behind', or when 'unstable' becomes 'clean').
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.pr_data.outputs.PR_NUMBER }}
          PR_HEAD_SHA: ${{ steps.pr_data.outputs.PR_HEAD_SHA }}
        run: |
          echo "Attempting to enable auto-merge for PR #$PR_NUMBER with HEAD SHA $PR_HEAD_SHA."
          echo "Current mergeable state: ${{ steps.pr_data.outputs.MERGE_STATE }}"
          gh pr merge "$PR_NUMBER" --auto --squash --delete-branch
          echo "Auto-merge enabled for PR #$PR_NUMBER. GitHub will merge when all conditions (no conflicts, passing required checks, met review policies) are satisfied."

      - name: Verify merge and update timestamp
        id: verify_merge
        # Run this step if auto-merge was attempted.
        # The PR merge happens asynchronously when using 'gh pr merge --auto'.
        # This step checks after a delay if the merge has occurred.
        if: steps.pr_data.outputs.IS_MERGEABLE == 'true' && (steps.pr_data.outputs.MERGE_STATE == 'clean' || steps.pr_data.outputs.MERGE_STATE == 'behind' || steps.pr_data.outputs.MERGE_STATE == 'unstable')
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.pr_data.outputs.PR_NUMBER }}
          PR_BASE_REF: ${{ steps.pr_data.outputs.PR_BASE_REF }}
        run: |
          echo "::set-output name=merged_successfully::false" # Default to false
          echo "Waiting 30 seconds for auto-merge to process..." # Increased wait time
          sleep 30 
          PR_MERGED_STATUS=$(gh pr view "$PR_NUMBER" --json merged --jq .merged)

          if [ "$PR_MERGED_STATUS" = "true" ]; then
            echo "PR #$PR_NUMBER was merged. Updating timestamp."
            echo "::set-output name=merged_successfully::true"
            
            # Checkout the base branch to commit the timestamp file
            # Ensure local ref is updated before checkout
            git fetch origin ${{ env.PR_BASE_REF }} 
            git checkout ${{ env.PR_BASE_REF }}
            # Ensure it's up-to-date with remote before pushing new commit
            git pull origin ${{ env.PR_BASE_REF }} 

            echo "$(date -u +%Y-%m-%dT%H:%M:%SZ)" > .last_successful_merge_timestamp
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git add .last_successful_merge_timestamp
            # Commit and push only if there are changes
            if ! git diff --staged --quiet; then
              git commit -m "CI: Update last successful PR merge timestamp after merging PR #$PR_NUMBER"
              # Retry push in case of minor transient issues
              for i in 1 2 3; do git push origin ${{ env.PR_BASE_REF }} && break || sleep 5; done
            else
              echo "No changes to .last_successful_merge_timestamp to commit (file likely already up-to-date)."
            fi
          else
            echo "PR #$PR_NUMBER not confirmed as merged after 30s wait. It might merge later if auto-merge conditions are met, or it might require manual action if checks fail or reviews are pending indefinitely."
          fi
      
      - name: Notify on merge processing (if merge not immediately confirmed)
        # This notification means the auto-merge was enabled, but the PR wasn't merged within the 30s check.
        # It's not strictly a "failure" of enabling auto-merge, but a status update.
        if: steps.pr_data.outputs.IS_MERGEABLE == 'true' &&             (steps.pr_data.outputs.MERGE_STATE == 'clean' || steps.pr_data.outputs.MERGE_STATE == 'behind' || steps.pr_data.outputs.MERGE_STATE == 'unstable') &&             steps.verify_merge.outputs.merged_successfully == 'false'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          PR_NUMBER: ${{ steps.pr_data.outputs.PR_NUMBER }}
          REPO_SLUG: ${{ github.repository }}
        run: |
          echo "Auto-merge for PR #$PR_NUMBER was enabled, but the merge was not confirmed after 30 seconds."
          echo "The PR may merge later if all conditions (passing checks, required reviews) are met."
          echo "If it remains unmerged, please check the PR for failing checks or other unsatisfied merge requirements: ${{ github.event.pull_request.html_url }}"
          # Optionally create an issue for follow-up if it's critical that it merges quickly
          # gh issue create --title "Auto-merge for PR #${PR_NUMBER} pending"           #                 --body "Auto-merge was enabled for PR #${PR_NUMBER} in repository ${REPO_SLUG}. It was not confirmed as merged after 30s. Please monitor. PR URL: ${{ github.event.pull_request.html_url }}"           #                 --label "automation,auto-merge-pending"

  change_visibility:
    runs-on: ubuntu-latest
    if: github.event_name == 'schedule' || github.event_name == 'workflow_dispatch'
    permissions:
      contents: read         # To read the .last_successful_merge_timestamp
      # administration: write  # This scope is not valid here. Token permissions are key.
      issues: write          # To create issues on failure
    steps:
      - name: Checkout code (default branch)
        uses: actions/checkout@v3
        with:
          ref: ${{ github.event.repository.default_branch || 'main' }}
          token: ${{ secrets.GITHUB_TOKEN }} 
          fetch-depth: 1 # Only need the latest commit to get the file

      - name: Get last successful merge timestamp
        id: last_merge_date
        run: |
          if [ -f .last_successful_merge_timestamp ]; then
            MERGE_TS=$(cat .last_successful_merge_timestamp)
            echo "timestamp=$MERGE_TS" >> $GITHUB_OUTPUT
            echo "Found last merge timestamp: $MERGE_TS"
          else
            echo "timestamp=1970-01-01T00:00:00Z" >> $GITHUB_OUTPUT
            echo "No .last_successful_merge_timestamp file found. Assuming no PRs merged by this workflow yet."
          fi

      - name: Check for open PRs
        id: open_prs
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} 
        run: |
          OPEN_PRS_COUNT=$(gh pr list --state open --limit 100 --json number --jq 'length')
          echo "count=$OPEN_PRS_COUNT" >> $GITHUB_OUTPUT
          echo "Found $OPEN_PRS_COUNT open PR(s)."

      - name: Calculate dates and decide on visibility change
        id: decision
        run: |
          LAST_MERGE_TIMESTAMP="${{ steps.last_merge_date.outputs.timestamp }}"
          LAST_MERGE_SECONDS=$(date -d "$LAST_MERGE_TIMESTAMP" +%s)
          SIX_MONTHS_AGO_SECONDS=$(date -d "now - 6 months" +%s)
          
          echo "Last merge timestamp: $LAST_MERGE_TIMESTAMP (Epoch: $LAST_MERGE_SECONDS)"
          echo "Six months ago timestamp: $(date -d @$SIX_MONTHS_AGO_SECONDS -u +%Y-%m-%dT%H:%M:%SZ) (Epoch: $SIX_MONTHS_AGO_SECONDS)"
          
          CHANGE_VISIBILITY="false"
          # NEW LOGIC: Only check timestamp, ignore open PR count for decision to change
          if [ "$LAST_MERGE_SECONDS" -lt "$SIX_MONTHS_AGO_SECONDS" ]; then
            if [ "$LAST_MERGE_TIMESTAMP" != "1970-01-01T00:00:00Z" ]; then # Ensure a merge has actually been recorded by the workflow
              CHANGE_VISIBILITY="true"
              echo "Decision: Last merge was over 6 months ago. Conditions met to change visibility to private (open PRs: ${{ steps.open_prs.outputs.count }} - will be ignored for decision)."
            else
              echo "Decision: Do not change visibility. No PRs have been recorded as merged by this workflow yet (timestamp is default)."
            fi
          else
            echo "Decision: Do not change visibility. Last merge ($LAST_MERGE_TIMESTAMP) was less than 6 months ago."
          fi
          echo "change_visibility=$CHANGE_VISIBILITY" >> $GITHUB_OUTPUT
          
      - name: Change repository visibility to private
        if: steps.decision.outputs.change_visibility == 'true'
        env:
          # CRITICAL: This token MUST have admin permissions for the repository.
          GH_TOKEN_FOR_VISIBILITY: ${{ secrets.REPO_ADMIN_PAT }} 
          GH_REPO: ${{ github.repository }}
        run: |
          echo "Attempting to change repository visibility to private for $GH_REPO."
          echo "$GH_TOKEN_FOR_VISIBILITY" | gh auth login --with-token
          gh repo edit "$GH_REPO" --visibility private
          
          sleep 5 # Give GitHub a moment to process the change
          NEW_VISIBILITY=$(gh repo view "$GH_REPO" --json visibility --jq .visibility)
          if [ "$NEW_VISIBILITY" = "PRIVATE" ]; then 
            echo "Repository visibility successfully changed to private."
            echo "::set-output name=visibility_changed_successfully::true"
          else
            echo "Failed to change repository visibility. Current visibility: $NEW_VISIBILITY"
            echo "This could be due to insufficient permissions for the token used (secrets.REPO_ADMIN_PAT)."
            echo "::set-output name=visibility_changed_successfully::false"
          fi
        id: change_visibility_step

      - name: Notify on visibility change failure
        if: steps.decision.outputs.change_visibility == 'true' && steps.change_visibility_step.outputs.visibility_changed_successfully == 'false'
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }} # Default token for creating issues
          REPO_SLUG: ${{ github.repository }}
        run: |
          echo "Failed to change repository visibility to private for $REPO_SLUG."
          gh issue create --title "Failed to change repository visibility to Private"                           --body "The workflow attempted to change the visibility of repository ${REPO_SLUG} to Private, but it failed. Please check the workflow logs and repository settings/permissions. Last merge timestamp: ${{ steps.last_merge_date.outputs.timestamp }}. Open PRs: ${{ steps.open_prs.outputs.count }}."                           --label "bug,automation,security" # Labels for the issue are kept as per your confirmation

      - name: Skip visibility change
        if: steps.decision.outputs.change_visibility == 'false'
        run: |
          echo "Skipping visibility change based on the calculated conditions."
